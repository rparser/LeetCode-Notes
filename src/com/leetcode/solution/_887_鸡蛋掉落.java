package com.leetcode.solution;

public class _887_鸡蛋掉落 {
//    你将获得 K 个鸡蛋，并可以使用一栋从 1 到 N  共有 N 层楼的建筑。
//
//    每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。
//
//    你知道存在楼层 F ，满足 0 <= F <= N 任何从高于 F 的楼层落下的鸡蛋都会碎，从 F 楼层或比它低的楼层落下的鸡蛋都不会破。
//
//    每次移动，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 X 扔下（满足 1 <= X <= N）。
//
//    你的目标是确切地知道 F 的值是多少。
//
//    无论 F 的初始值如何，你确定 F 的值的最小移动次数是多少？
//那么我们如何求出 f(T, K)f(T,K) 呢？我们还是使用动态规划。因为我们需要找出最高的 NN，因此我们不必思考到底在哪里扔这个鸡蛋，我们只需要扔出一个鸡蛋，看看到底发生了什么：
//
//    如果鸡蛋没有碎，那么对应的是 f(T−1,K)，也就是说在这一层的上方可以有 f(T−1,K) 层；
//
//    如果鸡蛋碎了，那么对应的是 f(T−1,K−1)，也就是说在这一层的下方可以有 f(T−1，K−1) 层。
//
//    因此我们就可以写出状态转移方程：
//
//    f(T, K) = 1 + f(T-1, K-1) + f(T-1, K)
//    边界条件为：当 T≥1 的时候 f(T, 1) = T，当 K≥1 时，f(1,K)=1。
//反过来想这个问题：如果我们可以做 TT 次操作，而且有 KK 个鸡蛋，那么我们能找到答案的最高的 NN 是多少
public int superEggDrop(int K, int N) {
    if (N == 1) {
        return 1;
    }
    int[][] f = new int[N + 1][K + 1];
    for (int i = 1; i <= K; ++i) {
        f[1][i] = 1;
    }
    int ans = -1;
    for (int i = 2; i <= N; ++i) {
        for (int j = 1; j <= K; ++j) {
            f[i][j] = 1 + f[i - 1][j - 1] + f[i - 1][j];
        }
        if (f[i][K] >= N) {
            ans = i;
            break;
        }
    }
    return ans;
}

}
